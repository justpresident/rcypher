# Implement a new extensible storage format that supports

## grouping secrets into folders
✅ **COMPLETED**
- Hierarchical folder structure with unlimited nesting depth
- Everything is in the root folder (/) by default
- Commands: `mkdir`, `cd`, `pwd` for folder navigation
- Full path support: `/work/projects/api_key`
- Relative paths: `../other_folder`, `./subfolder`
- Keys can be moved between folders using `mv` command
- Comprehensive test coverage for nested folders

## encryption domains
⚠️ **PARTIALLY COMPLETED**
- Data structures exist: `Folder` has `encryption_domain: u32` field
- `SecretValue` enum supports both plain and encrypted folder variants
- Default encryption domain (0) uses the master key (same as storage v4)

⏳ **TODO: CLI commands and functionality**
- Non-default domains should encrypt secrets with a custom key requiring another password
- Can be attached to either individual keys or folders
- When a folder has a non-default encrypted domain, all its contents should be encrypted together, such that it is impossible to know what is stored inside
- Should appear in the CLI UI as a regular key/value instead of a folder with a user-set value to confuse attackers in case master key is stolen
- "unlock" command for such a key asks for a password, decrypts its content and opens it for querying by all commands as if it was unencrypted

**Use case**
Encryption:
- User can call a command "lock {folder/key}" which would ask which encryption domain to use or to create a new one, password for it and a PlaceholderSecret value to show when it is locked.
- The value or a folder is immediately encrypted and stored encrypted in memory
- get/set/history commands work as if a PlaceholderSecret is a real stored secret value.

Decryption:
- get/set/history commands work as always as if a PlaceHolderSecret was a real value. set command can override the value even if it holds an encrypted folder underneath.
- "unlock key" command checks encryption domain and if a key for this domain is already cached, then it performs decryption and if it is a folder, decrypts its contents into memory making its contents available for get/set/history commands

## move command
✅ **COMPLETED: move command**
- `mv SOURCE_PATTERN DESTINATION` - shell-like move behavior
- Single match: destination can be folder or full path (move+rename)
- Multiple matches: destination must be a folder
- Recursive pattern matching with regex support
- Preserves full key history during move
- Collision detection with pre-validation

⏳ **TODO: encryption domain support for move**
- Encrypted folders must be unlocked to allow moving/renaming keys from them
- Re-encryption should be performed with key from corresponding encryption domain when moving between domains

## support SecretType and optional metadata HashMap
⚠️ **PARTIALLY COMPLETED**
- Data structures exist: `SecretEntry` has `secret_type: SecretType` and `metadata: HashMap<String, String>` fields
- Currently only `SecretType::Utf8String` is implemented
- Metadata field exists but not exposed in CLI

⏳ **TODO**
- Add `SecretType::File` variant for file storage support
- Implement CLI commands to set/view metadata
- Add file upload/download functionality
- Support for binary data storage
